# 1 - DNSプロトコルについて

まず、DNSプロトコルについて調べ、その知識をもとに簡単なクライアントを実装してみます。

従来、DNSのパケットはUDPトランスポートを使用して送信され、512バイトに制限されていました。後述しますが、この2つのルールには例外があります。DNSはTCPでも利用でき、eDNSという仕組みを使えばパケットサイズを拡張することができます。しかし、ここではオリジナルの仕様に従うことにします。

DNSは、クエリとレスポンスが同じフォーマットで行われるという点で非常に便利です。つまり、パケットパーサとパケットライタを1つ書いてしまえば、プロトコルの実装は完了してしまうのです。これは、リクエストとレスポンスの構造が異なるほとんどのインターネットプロトコルとは異なります。DNSのパケットは次のようになっています。

| セクション            | サイズ     | Type              | 目的                                                                                                |
| ------------------ | -------- | ----------------- | ------------------------------------------------------------------------------------------------------ |
| Header             | 12 Bytes | Header            | query/responseに関する情報                                                                  |
| Questionセクション   | 可変 | Questions\[\] | 実際には、クエリ名（ドメイン）と関心のあるレコードタイプを示す1つの`Question`のみです。 |
| Answerセクション     | 可変 | Records\[\]  | The relevant records of the requested type.                                                            |
| Authorityセクション  | 可変 | Records\[\]  | ネームサーバー（NSレコード）のリストで、クエリを再帰的に解決するために使用されます。 |
| Additionalセクション | 可変 | Records\[\]  | 役に立ちそうな追加のレコード。例えば、NSレコードに対応するAレコードなどです。 |

基本的には、`Header`,`Question`,`Record`という、3つの異なるオブジェクトをサポートする必要があります。

## ヘッダ(`Header`)のフォーマット

便利なことに、クエスチョン(`Question`)とレコード(`Record`)のリストは、単に個々のインスタンスが一列に追加されたもので、余分なものはありません。各セクションのレコードの数は、ヘッダ(`Header`)によって提供されます。ヘッダ構造は以下のようになります。

| RFC名 | 名称 | サイズ | 説明 |
| -------- | -------------------- | ------------------ | ------------------- |
| ID       | Packet Identifier    | 16 bits | クエリパケットにはランダムな識別子が割り当てられます。レスポンスパケットは同じIDで応答しなければなりません。これは、UDPのステートレスな性質のため、応答を区別するために必要です。       |
| QR       | Query Response       | 1 bit   | 0:クエリ, 1:レスポンス |
| OPCODE   | Operation Code       | 4 bits  | 常に0です。詳細は RFC1035 を参照してください。 |
| AA       | Authoritative Answer | 1 bit   | Set to 1 if the responding server is authoritative - that is, it "owns" - the domain queried. |
| TC       | Truncated Message    | 1 bit   | メッセージの長さが512バイトを超える場合、1に設定されます。従来は、長さの制限が適用されないTCPを使用してクエリを再発行できることを示唆していました。 |
| RD       | Recursion Desired    | 1 bit   | answer が見つからない場合に、サーバーが再帰的にクエリの解決を試みるかどうかを、リクエストの送信者が設定します。 |
| RA       | Recursion Available  | 1 bit   | 再帰的なクエリを許可するかどうかを示すためにサーバーが設定します。 |
| Z        | Reserved             | 3 bits  | 元々は後で使用するために予約されていましたが、現在はDNSSECのクエリに使用されています。 |
| RCODE    | Response Code        | 4 bits  | レスポンスのステータスを示すためにサーバーが設定します。つまり、レスポンスが成功したか失敗したかを示し、失敗した場合は失敗の原因に関する詳細を提供します。 |
| QDCOUNT  | Question Count       | 16 bits | Questionセクションのエントリ数 |
| ANCOUNT  | Answer Count         | 16 bits | Answerセクションのエントリ数 |
| NSCOUNT  | Authority Count      | 16 bits | Authorityセクションのエントリ数 |
| ARCOUNT  | Additional Count     | 16 bits | Additionalセクションのエントリ数 |

## クエスチョン(`Question`)のフォーマット

`Question`の構造はヘッダよりもシンプルなものになっています。

| フィールド名  | Type           | 説明                                                          |
| ------ | -------------- | -------------------------------------------------------------------- |
| Name   | Label Sequence | ドメイン名は、単純な1つの文字列でなく、後述のようにラベルのシーケンスとしてエンコードされます。 |
| Type   | 2-byte Integer | レコードのタイプ                                                   |
| Class  | 2-byte Integer | クラスを表すもので、常に1が設定されています。                              |

厄介なのはドメイン名のエンコーディングで、これについては後ほど説明します。

## レコード(`Record`)のフォーマット

最後に、プロトコルの核となるレコード(`Record`)を紹介します。レコードには多くの種類がありますが、ここではいくつかの重要なものだけを考えます。すべてのレコードには次のようなプリアンブルがあります。

| フィールド名  | Type           | 説明                                                                       |
| ------ | -------------- | --------------------------------------------------------------------------------- |
| Name   | Label Sequence | ドメイン名は、単純な1つの文字列でなく、後述のようにラベルのシーケンスとしてエンコードされます。              |
| Type   | 2-byte Integer | レコードのタイプ                                                                  |
| Class  | 2-byte Integer | Classを表すもので、常に1が設定されています。                                           |
| TTL    | 4-byte Integer | レコードがキャッシュされてからリクエリされるまでの時間を表します。 |
| Len    | 2-byte Integer | レコードタイプごとに特有のデータの長さ。                                          |

## 実際に見てみよう

これで、特定のレコードタイプを見る準備が整いました。最も重要な**Aレコード**から始めましょう。

| フィールド名      | Type            | 説明                                        |
| ---------- | --------------- | -------------------------------------------------- |
| Preamble   | Record Preamble | プリアンブル(上述)で、`Len`フィールドは4に設定されています。|
| IP         | 4-byte Integer  | 4バイト整数としてエンコードされたIPアドレス               |

IPが4バイトなので、プリアンブルの`Len`フィールドが4になっています。

ここまではいいとして、実際に`dig`ツールを使って検索してみましょう。

```sh
$ dig +noedns google.com

; <<>> DiG 9.10.3-P4-Ubuntu <<>> +noedns google.com
;; global options: +cmd
;; Got answer:
;; ->>HEADER<<- opcode: QUERY, status: NOERROR, id: 36383
;; flags: qr rd ra ad; QUERY: 1, ANSWER: 1, AUTHORITY: 0, ADDITIONAL: 0

;; QUESTION SECTION:
;google.com.                    IN      A

;; ANSWER SECTION:
google.com.             204     IN      A       172.217.18.142

;; Query time: 0 msec
;; SERVER: 192.168.1.1#53(192.168.1.1)
;; WHEN: Wed Jul 06 13:24:19 CEST 2016
;; MSG SIZE  rcvd: 44
```

オリジナルのフォーマットにこだわるために、`+noedns`フラグを使用しています。上の出力にはいくつかの注意すべき点があります。

- `dig`では、レスポンスパケットのヘッダー、クエスチョン、レスポンスセクションが明示されていることがわかります。
- ヘッダーは0に対応する`OPCODE QUERY`を使用しています。ステータス（`RESCODE`）は`NOERROR`に設定されており、数値的には0になります。IDは36383で、クエリを繰り返すことでランダムに変化します。Query Response（qr）、Recursion Desired（rd）、Recursion Available（ra）フラグが有効になっており、数値的には1になっています。adはDNSSECに関連しているので、今は無視しても大丈夫です。最後に、ヘッダーは1つのクエスチョンと1つのレスポンスのレコードがあることを示しています。
- クエスチョンセクションでは、クエスチョンが表示されます。`IN`はクラスを示し、`A`はAレコードに対するクエリを実行していることを示しています。
- アンサーセクションには、googleのIPを含むアンサーレコードが含まれています。`204`はTTL、`IN`は再びクラス、`A`はレコードタイプを表しています。最後に、google.comのIPアドレスを取得しています。
- 最後の行では、パケットの合計サイズが44バイトであることを示しています。

しかし、まだ見ていない情報があるので、さらに深く掘り下げて、パケットをHexでダンプしたものを見てみましょう。

`netcat`を使ってポートをリッスンし、`dig`にクエリを送信するよう指示することができます。ターミナルウィンドウで次のように実行します。

```sh
$ nc -u -l 1053 > query_packet.txt
```

別のターミナルウィンドウで`dig`を実行すると次のようになります。

```sh
$ dig +retry=0 -p 1053 @127.0.0.1 +noedns google.com

; <<>> DiG 9.10.3-P4-Ubuntu <<>> +retry=0 -p 1053 @127.0.0.1 +noedns google.com
; (1 server found)
;; global options: +cmd
;; connection timed out; no servers could be reached
```

`dig`はレスポンスを受け取らないとタイムアウトするので、この場合は失敗が予想されます。

実際、これは失敗するので、終了します。

この時点で`netcat`は`Ctrl+C`で終了しても大丈夫です。なぜなら`query_packet.txt`には、`dig`からのクエリパケットが残ります。

このクエリパケットを使って、レスポンスパケットを次のように記録することができます。

```sh
$ nc -u 8.8.8.8 53 < query_packet.txt > response_packet.txt
```

1秒待ってから、`Ctrl+C`でキャンセルします。これで、パケットを検査する準備ができました。

```sh
$ hexdump -C query_packet.txt
00000000  86 2a 01 20 00 01 00 00  00 00 00 00 06 67 6f 6f  |.*. .........goo|
00000010  67 6c 65 03 63 6f 6d 00  00 01 00 01              |gle.com.....|
0000001c

$ hexdump -C response_packet.txt
00000000  86 2a 81 80 00 01 00 01  00 00 00 00 06 67 6f 6f  |.*...........goo|
00000010  67 6c 65 03 63 6f 6d 00  00 01 00 01 c0 0c 00 01  |gle.com.........|
00000020  00 01 00 00 01 25 00 04  d8 3a d3 8e              |.....%...:..|
0000002c
```

このことを理解できるかどうか見てみましょう。

先ほどから、ヘッダーは12バイトであることがわかっています。クエリパケットの場合、ヘッダのバイトは次のようになります: `86 2a 01 20 00 01 00 00 00 00 00 00`

末尾の8バイトは各セクションの長さに対応しており、実際にコンテンツを持っているのは、1つのエントリを持つクエスチョンセクションだけであることがわかります。

さらに興味深いのは、最初の4バイトで、これはヘッダのさまざまなフィールドに対応しています。

まず、2バイトのIDがありますが、これはクエリパケットとレスポンスパケットの両方で同じであるはずです。実際、この例では、クエリとレスポンスの両方のHexダンプで`86 2a`に設定されていることがわかります。

解析が難しいのは、残りの2バイトです。

ビットごとに意味を持っているため、理解するためには、バイナリ表記に変換する必要があります。クエリパケットの`01 20`から始めると、（最上位ビットから順に）次のようになります。

```
0 0 0 0 0 0 0 1  0 0 1 0 0 0 0 0
- -+-+-+- - - -  - -+-+- -+-+-+-
Q    O    A T R  R   Z      R
R    P    A C D  A          C
     C                      O
     O                      D
     D                      E
     E
```

`Z`セクションの`DNSSEC`関連のビットを除いて、これは予想通りです。

`QR`はクエリなので0となり、`OPCODE`も標準的なルックアップなので0です。

`AA`,`TC`,`RA`のフラグは`RD`がセットされている間はクエリには関係ありません。それは`dig`はデフォルトで再帰的ルックアップを要求するからです。最後に、`RCODE`もクエリには使用されません。

次にレスポンスパケットの後半2バイト(`81 80`)を見ていきましょう。

```
1 0 0 0 0 0 0 1  1 0 0 0 0 0 0 0
- -+-+-+- - - -  - -+-+- -+-+-+-
Q    O    A T R  R   Z      R
R    P    A C D  A          C
     C                      O
     O                      D
     D                      E
     E
```

これはレスポンスなので`QR`がセットされており、サーバーが再帰をサポートしていることを示すために`RA`が設定されています。

レスポンスの残りの8バイトを見ると、1つのクエスチョンに加えて、1つのアンサーレコードを持っていることがわかります。

ヘッダーの直後にはクエスチョンがあります。バイトごとに分解してみましょう。

```
                    query name              type   class
       -----------------------------------  -----  -----
HEX    06 67 6f 6f 67 6c 65 03 63 6f 6d 00  00 01  00 01
ASCII     g  o  o  g  l  e     c  o  m
DEC    6                    3           0       1      1
```

先ほどの表で説明したように、クエリ名、タイプ、クラスの3つの部分で構成されています。

しかし、名前のエンコード方法には興味深い点があり、ドットがありません。

DNSは各名前を`labels`という文字列の配列にエンコードし、各ラベルの前にはその長さを示す1バイトが付けられます。

上の例では、"google"は6バイトなので`0x06`が、"com"は3バイトなので`0x03`が先頭に付けられています。`["google", "com"]` 

最後に、すべての名前は、長さが0のラベル、つまりヌルバイトで締めくくられます。 簡単そうに見えますよね？ しかし、すぐに分かるように、これには変わった点があります。

クエリパケットはこれで終わりですが、レスポンスパケットにはデコードすべきデータが残っています。残っているデータは、google.com の対応するIPアドレスを示す1つのAレコードです。

```
      name     type   class         ttl        len      ip
      ------  ------  ------  --------------  ------  --------------
HEX   c0  0c  00  01  00  01  00  00  01  25  00  04  d8  3a  d3  8e
DEC   192 12    1       1           293         4     216 58  211 142
```

ほとんどが予想通りです。

TypeはAレコードを表す`1`、クラスは`IN`を表す`1`となっています。

この場合のTTLは293で正常な値であり、データの長さは4で先程の説明通りです。

そして最後にgoogleのIPは`216.58.211.142`であることがわかりました。

では、名前欄には何が起こっているのでしょうか？ 先ほど学んだラベルはどこにあるのでしょうか？

1つのパケットが512バイトというDNSの元々のサイズ制限のため、何らかの圧縮が必要でした。必要な容量のほとんどはドメイン名のためのものであり、同じ名前の部分は繰り返し使われる傾向があるため、明らかにスペースを節約できる機会があります。例えば、次のようなDNSクエリを考えてみましょう。

```sh
$ dig @a.root-servers.net com

- snip -

;; AUTHORITY SECTION:
com.                172800  IN  NS      e.gtld-servers.net.
com.                172800  IN  NS      b.gtld-servers.net.
com.                172800  IN  NS      j.gtld-servers.net.
com.                172800  IN  NS      m.gtld-servers.net.
com.                172800  IN  NS      i.gtld-servers.net.
com.                172800  IN  NS      f.gtld-servers.net.
com.                172800  IN  NS      a.gtld-servers.net.
com.                172800  IN  NS      g.gtld-servers.net.
com.                172800  IN  NS      h.gtld-servers.net.
com.                172800  IN  NS      l.gtld-servers.net.
com.                172800  IN  NS      k.gtld-servers.net.
com.                172800  IN  NS      c.gtld-servers.net.
com.                172800  IN  NS      d.gtld-servers.net.

;; ADDITIONAL SECTION:
e.gtld-servers.net. 172800  IN  A       192.12.94.30
b.gtld-servers.net. 172800  IN  A       192.33.14.30
b.gtld-servers.net. 172800  IN  AAAA    2001:503:231d::2:30
j.gtld-servers.net. 172800  IN  A       192.48.79.30
m.gtld-servers.net. 172800  IN  A       192.55.83.30
i.gtld-servers.net. 172800  IN  A       192.43.172.30
f.gtld-servers.net. 172800  IN  A       192.35.51.30
a.gtld-servers.net. 172800  IN  A       192.5.6.30
a.gtld-servers.net. 172800  IN  AAAA    2001:503:a83e::2:30
g.gtld-servers.net. 172800  IN  A       192.42.93.30
h.gtld-servers.net. 172800  IN  A       192.54.112.30
l.gtld-servers.net. 172800  IN  A       192.41.162.30
k.gtld-servers.net. 172800  IN  A       192.52.178.30
c.gtld-servers.net. 172800  IN  A       192.26.92.30
d.gtld-servers.net. 172800  IN  A       192.31.80.30

- snip -
```

ここでは、インターネットのルートサーバーのひとつに、`.com`TLDを扱うネームサーバーを問い合わせています。

`gtld-servers.net.`が何度も登場していることに注目してください。

これを一度だけ入れればいいのであればサイズの削減にかなり効果的だと思いませんか？ これを実現する1つの方法は、パケットパーサーに別の位置にジャンプして、そこで名前を読み終えるように指示する「ジャンプ指示文」を含めることです。結果的には、それがまさに私たちが見ているレスポンスパケットの内容です。

先ほど、各ラベルの前には1バイトの長さがあると述べました。さらに考慮しなければならないのは、`Len`の2つの最上位ビットが設定されている場合、代わりに長さのバイトの後に2つ目のバイトが続くことが予想されることです。

この2つのバイトを合わせて、2つのMSBを取り除いたものがジャンプ位置を示します。上の例では、`0xC00C`となっています。上位2ビットのビットパターンを16進数で表すと`0xC000`なので、このマスクで2バイトをXORしてアンセットすれば、ジャンプ位置が12だとわかります。`0xC00C ^ 0xC000 = 0x000C = 12`

したがって、パケットのバイト12にジャンプして、そこから読み取るべきです。

DNSヘッダの長さがたまたま12バイトだったことを思い出すと、パケットのクエスチョン部分が始まるところから読み始めるように指示していることがわかります。質問はクエリドメイン（この場合は "google.com"）で始まるので、これは理にかなっています。名前の読み取りが終わると、前回の続きから解析を再開し、レコードタイプに進みます。

## BytePacketBuffer

TODO

