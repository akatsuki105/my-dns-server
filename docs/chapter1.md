# 1 - The DNS protocol

まず、DNSプロトコルについて調べ、その知識をもとに簡単なクライアントを実装してみます。

従来、DNSのパケットはUDPトランスポートを使用して送信され、512バイトに制限されていました。後述しますが、この2つのルールには例外があります。DNSはTCPでも利用でき、eDNSという仕組みを使えばパケットサイズを拡張することができます。しかし、ここではオリジナルの仕様に従うことにします。

DNSは、問い合わせと応答が同じフォーマットで行われるという点で非常に便利です。つまり、パケットパーサとパケットライタを書いてしまえば、プロトコルの実装は完了してしまうのです。これは、リクエストとレスポンスの構造が異なるほとんどのインターネットプロトコルとは異なります。DNSのパケットは次のようになっています。

| セクション            | サイズ     | Type              | 目的                                                                                                |
| ------------------ | -------- | ----------------- | ------------------------------------------------------------------------------------------------------ |
| Header             | 12 Bytes | Header            | query/responseに関する情報                                                                  |
| Questionセクション   | 可変 | Questions\[\] | 実際には、クエリ名（ドメイン）と関心のあるレコードタイプを示す1つの質問のみです。 |
| Answerセクション     | 可変 | Records\[\]  | The relevant records of the requested type.                                                            |
| Authorityセクション  | 可変 | Records\[\]  | ネームサーバー（NSレコード）のリストで、クエリを再帰的に解決するために使用されます。 |
| Additionalセクション | 可変 | Records\[\]  | 役に立ちそうな追加のレコード。例えば、NSレコードに対応するAレコードなどです。 |

基本的には、`Header`,`Question`,`Record`という、3つの異なるオブジェクトをサポートする必要があります。

便利なことに、レコードと質問のリストは、単に個々のインスタンスが一列に追加されたもので、余分なものはありません。各セクションのレコードの数は、ヘッダ(`Header`)によって提供されます。ヘッダ構造は以下のようになります。

| RFC名 | 名称 | サイズ | 説明 |
| -------- | -------------------- | ------------------ | ------------------- |
| ID       | Packet Identifier    | 16 bits | クエリパケットにはランダムな識別子が割り当てられます。レスポンスパケットは同じIDで応答しなければなりません。これは、UDPのステートレスな性質のため、応答を区別するために必要です。       |
| QR       | Query Response       | 1 bit   | 0:クエリ, 1:レスポンス |
| OPCODE   | Operation Code       | 4 bits  | 常に0です。詳細は RFC1035 を参照してください。 |
| AA       | Authoritative Answer | 1 bit   | Set to 1 if the responding server is authoritative - that is, it "owns" - the domain queried. |
| TC       | Truncated Message    | 1 bit   | メッセージの長さが512バイトを超える場合、1に設定されます。従来は、長さの制限が適用されないTCPを使用してクエリを再発行できることを示唆していました。 |
| RD       | Recursion Desired    | 1 bit   | answer が見つからない場合に、サーバーが再帰的にクエリの解決を試みるかどうかを、リクエストの送信者が設定します。 |
| RA       | Recursion Available  | 1 bit   | 再帰的なクエリを許可するかどうかを示すためにサーバーが設定します。 |
| Z        | Reserved             | 3 bits  | 元々は後で使用するために予約されていましたが、現在はDNSSECのクエリに使用されています。 |
| RCODE    | Response Code        | 4 bits  | レスポンスのステータスを示すためにサーバーが設定します。つまり、レスポンスが成功したか失敗したかを示し、失敗した場合は失敗の原因に関する詳細を提供します。 |
| QDCOUNT  | Question Count       | 16 bits | Questionセクションのエントリ数 |
| ANCOUNT  | Answer Count         | 16 bits | Answerセクションのエントリ数 |
| NSCOUNT  | Authority Count      | 16 bits | Authorityセクションのエントリ数 |
| ARCOUNT  | Additional Count     | 16 bits | Additionalセクションのエントリ数 |

`Question`の構造はヘッダよりもシンプルなものになっています。

| フィールド名  | Type           | 説明                                                          |
| ------ | -------------- | -------------------------------------------------------------------- |
| Name   | Label Sequence | ドメイン名は、後述のようにラベルのシーケンスとしてエンコードされます。 |
| Type   | 2-byte Integer | レコードのタイプ                                                   |
| Class  | 2-byte Integer | Classを表すもので、常に1が設定されています。                              |

厄介なのはドメイン名のエンコーディングで、これについては後ほど説明します。

最後に、プロトコルの核となるレコード(`Record`)を紹介します。レコードには多くの種類がありますが、ここではいくつかの重要なものだけを考えます。すべてのレコードには次のようなプリアンブルがあります。

| フィールド名  | Type           | 説明                                                                       |
| ------ | -------------- | --------------------------------------------------------------------------------- |
| Name   | Label Sequence | ドメイン名は、後述のようにラベルのシーケンスとしてエンコードされます。              |
| Type   | 2-byte Integer | レコードのタイプ                                                                  |
| Class  | 2-byte Integer | Classを表すもので、常に1が設定されています。                                           |
| TTL    | 4-byte Integer | レコードがキャッシュされてからリクエリされるまでの時間を表します。 |
| Len    | 2-byte Integer | レコードタイプごとに特有のデータの長さ。                                          |

これで、特定のレコードタイプを見る準備が整いました。最も重要な**Aレコード**から始めましょう。

| フィールド名      | Type            | 説明                                        |
| ---------- | --------------- | -------------------------------------------------- |
| Preamble   | Record Preamble | プリアンブル(上述)で、`Len`フィールドは4に設定されています。|
| IP         | 4-byte Integer  | 4バイト整数としてエンコードされたIPアドレス               |

IPが4バイトなので、プリアンブルの`Len`フィールドが4になっています。

ここまではいいとして、実際に`dig`ツールを使って検索してみましょう。

```sh
$ dig +noedns google.com

; <<>> DiG 9.10.3-P4-Ubuntu <<>> +noedns google.com
;; global options: +cmd
;; Got answer:
;; ->>HEADER<<- opcode: QUERY, status: NOERROR, id: 36383
;; flags: qr rd ra ad; QUERY: 1, ANSWER: 1, AUTHORITY: 0, ADDITIONAL: 0

;; QUESTION SECTION:
;google.com.                    IN      A

;; ANSWER SECTION:
google.com.             204     IN      A       172.217.18.142

;; Query time: 0 msec
;; SERVER: 192.168.1.1#53(192.168.1.1)
;; WHEN: Wed Jul 06 13:24:19 CEST 2016
;; MSG SIZE  rcvd: 44
```

オリジナルのフォーマットにこだわるために、`+noedns`フラグを使用しています。上の出力にはいくつかの注意すべき点があります。

- `dig`では、レスポンスパケットのヘッダー、クエスチョン、レスポンスセクションが明示されていることがわかります。
- ヘッダーは0に対応する`OPCODE QUERY`を使用しています。ステータス（`RESCODE`）は`NOERROR`に設定されており、数値的には0になります。IDは36383で、クエリを繰り返すことでランダムに変化します。Query Response（qr）、Recursion Desired（rd）、Recursion Available（ra）フラグが有効になっており、数値的には1になっています。adはDNSSECに関連しているので、今は無視しても大丈夫です。最後に、ヘッダーは1つのクエスチョンと1つのレスポンスのレコードがあることを示しています。
- クエスチョンセクションでは、クエスチョンが表示されます。`IN`はクラスを示し、`A`はA個のレコードに対するクエリを実行していることを示しています。
- アンサーセクションには、googleのIPを含むアンサーレコードが含まれています。`204`はTTL、`IN`は再びクラス、`A`はレコードタイプを表しています。最後に、google.comのIPアドレスを取得しています。
- 最後の行では、パケットの合計サイズが44バイトであることを示しています。

しかし、まだ見ていない情報があるので、さらに深く掘り下げて、パケットをHexでダンプしたものを見てみましょう。

`netcat`を使ってポートをリッスンし、`dig`にクエリを送信するよう指示することができます。ターミナルウィンドウで次のように実行します。

```sh
$ nc -u -l 1053 > query_packet.txt
```

別のターミナルウィンドウで`dig`を実行すると次のようになります。

```sh
$ dig +retry=0 -p 1053 @127.0.0.1 +noedns google.com

; <<>> DiG 9.10.3-P4-Ubuntu <<>> +retry=0 -p 1053 @127.0.0.1 +noedns google.com
; (1 server found)
;; global options: +cmd
;; connection timed out; no servers could be reached
```

`dig`はレスポンスを受け取らないとタイムアウトするので、この場合は失敗が予想されます。

実際、これは失敗するので、終了します。

この時点で`netcat`は`Ctrl+C`で終了することができます。

`query_packet.txt`には、クエリパケットが残ります。このクエリパケットを使って、レスポンスパケットも記録することができます。

```sh
$ nc -u 8.8.8.8 53 < query_packet.txt > response_packet.txt
```

1秒待ってから、`Ctrl+C`でキャンセルします。これで、パケットを検査する準備ができました。

```sh
$ hexdump -C query_packet.txt
00000000  86 2a 01 20 00 01 00 00  00 00 00 00 06 67 6f 6f  |.*. .........goo|
00000010  67 6c 65 03 63 6f 6d 00  00 01 00 01              |gle.com.....|
0000001c

$ hexdump -C response_packet.txt
00000000  86 2a 81 80 00 01 00 01  00 00 00 00 06 67 6f 6f  |.*...........goo|
00000010  67 6c 65 03 63 6f 6d 00  00 01 00 01 c0 0c 00 01  |gle.com.........|
00000020  00 01 00 00 01 25 00 04  d8 3a d3 8e              |.....%...:..|
0000002c
```

TODO
